/* jshint node: true */
'use strict';

/*
This file was generated by generator-ffwd,
you probably should not modify it
*/

module.exports = function(grunt) {
  grunt.registerMultiTask('ffwd-doc', function() {
    var done      = this.async();
    var fs        = require('fs');
    var path      = require('path');
    var options   = grunt.task.current.options({'private': true});
    var config    = grunt.config.get();
    var done      = grunt.task.current.async();
    var srcs      = grunt.task.current.filesSrc;
    var cwd       = process.cwd();
    var utils     = require('ffwd-utils/server');
    var _         = utils._;
    var cmd       = 'node_modules/.bin/jsdoc';
    var args      = ['-X', '-r'];
    var pkg       = {};
    var deps      = {};
    var clientDeps = ['client/scripts'];
    var serverDeps = ['server'];
    var d;
    var type;
    var name;
    var info;
    var depPath;
    var clientPath;
    var serverPath;

    function cleanData(data) {
      var items = [];
      _.each(data, function(item) {
        if (item.undocumented) {
          return;
        }
        if (item.meta) {
          delete item.meta.range;
          delete item.meta.code;
          item.meta.path = path.relative(cwd, item.meta.path);
        }
        items.push(item);
      });
      return items;
    }
    
    options.destination = options.destination || 'doc';

    grunt.file.mkdir(options.destination);

    try {
      deps = utils.features();
    }
    catch (err) {
      done(err);
    }

    for (name in deps) {
      clientPath = path.join(deps[name], 'client/scripts');
      serverPath = path.join(deps[name], 'server');
      
      if (grunt.file.exists(clientPath)) {
        grunt.log.writeln('will parse '+ name +' client at '+ clientPath);
        clientDeps.push(clientPath);
      }
      else {
        grunt.log.writeln('no scripts to parse for '+ name +' client at '+ clientPath);
      }
      
      if (grunt.file.exists(serverPath)) {
        grunt.log.writeln('will parse '+ name +' server at '+ serverPath);
        serverDeps.push(serverPath);
      }
      else {
        grunt.log.writeln('no scripts to parse for '+ name +' server at '+ serverPath);
      }
    }


    var dest, data;
    grunt.util.spawn({
      cmd: cmd,
      args: args.concat(clientDeps)
    }, function(error, result, code) {
      if (error) {
        return done(error);
      }
      dest = path.join(options.destination, 'client.json');
      data = JSON.parse(result.stdout);
      data = cleanData(data);

      grunt.file.write(dest, JSON.stringify(data, null, 2));
      grunt.log.writeln('wrote '+ dest);
  
      grunt.util.spawn({
        cmd: cmd,
        args: args.concat(serverDeps)
      }, function(error, result, code) {
        if (error) {
          return done(error);
        }
        dest = path.join(options.destination, 'server.json');
        data = JSON.parse(result.stdout);
        data = cleanData(data);

        grunt.file.write(dest, JSON.stringify(data, null, 2));
        grunt.log.writeln('wrote '+ dest);
  
        done();
      });
    });
  });
};